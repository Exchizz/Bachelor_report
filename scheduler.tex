\textit{This capter concerns only the Atmega.  The ESP module will be descriped in section \ref{sec:esp_firmware}} \\
In order to have a timing on the At90CAN128 a scheduler was chosen and implemented.
The list below shows 3 different types of scheduler that was considered.
\begin{itemize}
	\item Real-time Operating System(RTOS) provides strict timing but at the cost of overhead. A RTOS runs task in a "parallel" environment. Each task runs in a loop and the RTOS scheduler will do context switching when needed. Using a RTOS requires mutexes and semaphores to protect shared resources which increases the complexity and amount of overhead
	\item Super-Loop provides no timing at all, but process data as fast as possible. It does not do any context switching and does not require mutexes or semaphores and  and thereby takes no overhead.
	\item Run-To-Complete(RTCS) scheduler is a mix of the two other schedulers. It works by waiting for a tick generated by a hardware timer and then starts executing all tasks from the beginning. The order of the task matters if there is dependency between the tasks but also to make sure the task requiring the most precise timing is at the beginning of the list of the tasks. All tasks have to be finished executing before the next tick is giving in order to avoid timing is ruined.
\end{itemize}
The RTCS was chosen since it provides timing without the overhead created when doing context-switching and the need of mutex and semaphores. It further reduces the code-complexity.\\

\Mathias{A little description about the scheduler implementation. Add tasks, and run the scheduler. Show how it waits for tick and the runs through all of the tasks that is in RUN state.}

It was decided to implement the code in tasks to make a low coupling between the functionalities. This makes it easier to maintain and expand later of if needed. The task diagram shown in figure \ref{fig:task_diagram_atmega} shows the tasks and how they do intertask communication.


\begin{figure}[H]
    \center
    \includegraphics[width=0.9\textwidth]{graphics/task_diagram.png}
  \caption{Tasks diagram showing overview of the running tasks on the At90Can128}
    \label{fig:task_diagram_atmega}
\end{figure}
A small description of each of the tasks is given below:
\begin{itemize}
\item \textbf{ is\_alive\_task} Toggles the green led to make sure the scheduler is running. In case of stack overflow, memoryleak or any other error, the Atmega will freeze and it will easily be detectable since the green led stops blinking
\item \textbf{ uart0\_tx\_task} Responsible of sending characters in the uart0\_tx queue.
\item \textbf{ uart0\_rx\_task} Responsible of checking if any characters in the uart-receive buffer is available. If any, put them into the uart0\_rx queue
\item \textbf{ uart1\_tx\_task} Responsibile as uart\_0\_tx\_task
\item \textbf{ uart1\_rx\_task} Responsibile as uart\_0\_rx\_task
\item \textbf{ can\_rx\_task} Responsible of checking if a CAN-message is available in the MOB. If any put them into the CAN\_rx\_queue
\item \textbf{ can\_tx\_task} Responsible of transmitting messages available in the CAN\_tx\_queue
\item \textbf{ aq\_node\_task} Responsible of registering the node when AQ boots.
\item \textbf{ task\_slip\_decode\_crc\_task} Responsible of removing SLIP characters and run CRC
\item \textbf{ aq\_spoof\_task} Responsible of converting and transmitting received GPS messages from uart1.
\end{itemize}
\Mathias{Add description of slip and crc task, maybe also spoof and node, not sure..}

\subsubsection*{Test of RTCS timing}
In order to test the timing of the scheduler, a led\_task was written. The task can be seen in code \ref{code:test_scheduler}
\begin{lstlisting}[language = c, caption = RTCS task used in timing test, label=code:test_scheduler]
void is_alive_task(uint8_t my_state){

	// Write to UART0
	UDR0 = my_state+'0';

	switch(my_state){
	case 0:
		INT_LED_ON_GREEN;
		INT_LED_OFF_RED;
		INT_LED_OFF_BLUE;
	    set_state( 1 );
		break;
	case 1:
		INT_LED_OFF_GREEN;
		INT_LED_ON_RED;
		INT_LED_OFF_BLUE;
	    set_state( 2 );
		break;
	case 2:
		INT_LED_OFF_GREEN;
		INT_LED_OFF_RED;
		INT_LED_ON_BLUE;

		// Set next state
	    set_state( 0 );
		break;
	}
	// Wait one second
	wait( 1000 );
}
\end{lstlisting}

The test was done by writing the current state of the task to UART0.\\ A python script were made that measures the time between each character received. The script can be seen in code \ref{code:test_rtcs_python}.
\begin{lstlisting}[language = python, caption = Python code used to measure time between received byte, label=code:test_rtcs_python]
#!/usr/bin/python
import serial
import time

ser = serial.Serial( port='/dev/ttyUSB0', baudrate=57600 )

t = time.time()
while True:
    char =  ser.read(1):
    print time.time() - t, ","
    t = time.time()

ser.close()
\end{lstlisting}
The output of the script were redirected to a file. After receiving 700 bytes the standard deviation and mean was calculated using matlab.
The mean is 1.0089 sec with a standard deviation of 0.0042 sec.

Part of the variance is caused by the inaccuracy of the timing on the PC running the python code. If a more accurate measure was needed, a scope could be attached to the $\mu$C's GPIO. Each time the scheduler enters the task the GPIO should be set high, and when it exists the GPIO should be set low. The scopes at SDU is capable of telling the variance of the off signal. \\
It can be concluded that the scheduler performs well.