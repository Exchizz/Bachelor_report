\textit{This captor concerns only the At90CAN128.  The ESP8266 module is described in section \ref{sec:exp8266_firmware}} \\
In order to have a timing on the At90CAN128 a scheduler was chosen and implemented.
The list below shows 3 different types of scheduler that was considered.
\begin{itemize}
	\item Real-time Operating System(RTOS) provides strict timing but at the cost of overhead. A RTOS runs task in a "parallel" environment. Each task runs in a loop and the RTOS scheduler will do context switching when needed. Using a RTOS requires mutexes and semaphores to protect shared resources which increases the complexity and amount of overhead.
	\item Super-Loop provides no timing at all, but process data as fast as possible. It does not do any context switching and does not require mutexes or semaphores and  and thereby takes no overhead.
	\item Run-To-Complete(RTCS) scheduler is a mix of the two other schedulers. It works by waiting for a tick generated by a hardware timer and then starts executing all tasks from the beginning. The order of the task matters if there is dependency between the tasks but also to make sure the task requiring the most precise timing is at the beginning of the list of the tasks. All tasks have to be finished executing before the next tick is giving in order to avoid timing is ruined.
\end{itemize}
The RTCS was chosen since it provides timing without the overhead created when doing context-switching and the need of mutex and semaphores. It further reduces the code-complexity.

The firmware was written in C++ to use the same \ac{AQ} CAN-message generation code running on the \ac{RPi}, on the At90CAN128.
The scheduler has been implemented with a minimum functionality.

It supports a software timer which is useful if a \ac{LED} needs to be toggled every x ticks. To use the timer  \textit{wait(ticks)} has to be called from within a task with the number of ticks to wait.
The task will not be executed until the wait period has passed. Each task has its own state-variable which is parsed as a parameter to the task. By calling \textit{set\_state( state )} from within a task, the state-variable can be updated. This was implemented to avoid the need of static or global variables in order for each task to have its own state-machine.

\begin{lstlisting}[language = Matlab, caption = Pseudo code of the RTCS scheduler implemented, label=code:rtcs_implemented]
def scheduler():
	for(ever):
		while(ticks != 1);
		ticks = 0
		for task in tasks:
			if task.task_state == ST_RUN or task.wait_counter== 0:
				task.task_state = ST_RUN
				current_state = task.state
				task.task_ptr(current_state)
			else: // task_state == ST_WAIT
				task.wait_counter--
\end{lstlisting}

\ref{code:rtcs_implemented} shows pseudo code of the scheduler. When tick is different from zero it loops through an array of task. If the current state of the task is ST\_RUN or the wait\_counter is zero, then invoke the callback which is defined when creating a task. If the task is in ST\_WAIT state simply decrement the counter.

Queues was implemented as circular-buffer to handle communication between the tasks. The queues was designed to be generic in order to contains elements of different size. When a queue is created, the size of each element is specified as a parameter.

\begin{lstlisting}[language = C++, caption = Implementation of queues. Notice the queues are generic in size since the size of the element is given as parameter. When a element is put into the queue\, it is done by multiplying the elements size by the index of the next element in the queue and add that to the beginning of the memory allocated for the queue, label=code:rtcs_queue]
// Create queue of 10 elements of 1 byte (main.cpp)
Queue_Uart0_Rx  = QueueCreate(10, sizeof(uint8_t));

// From QueueSend(&Queue_Uart0_Rx, &ch), put element into the allocated memory.
memcpy ( queue->mem + ( (queue->typesize)*(queue->wr) ), dataIn, queue->typesize );
\end{lstlisting}


It was decided to implement the code in tasks to make a low coupling between the functionalities. This makes it easier to maintain and expand later if needed. The task diagram shown in figure \ref{fig:task_diagram_atmega} shows the tasks and how they do inter-task communication using queues.

A hardware timer was configured to set \textit{ticks = 1} at every 1 ms. This means the scheduler is running through all tasks with a frequency of 1khz.

\begin{figure}[H]
    \center
    \includegraphics[width=0.9\textwidth]{graphics/task_diagram.png}
  \caption{Tasks diagram showing overview of the running tasks on the At90CAN128}
    \label{fig:task_diagram_atmega}
\end{figure}
A small description of each of the tasks is given below:
\begin{itemize}
\item \textbf{ is\_alive\_task} Toggles the green led to make sure the scheduler is running.
\item \textbf{ uart0\_tx\_task} Responsible of sending characters in the uart0\_tx queue.
\item \textbf{ uart0\_rx\_task} Responsible of checking if any characters in the uart-receive buffer is available. If any, put them into the uart0\_rx queue
\item \textbf{ uart1\_tx\_task} Responsibile as uart\_0\_tx\_task
\item \textbf{ uart1\_rx\_task} Responsibile as uart\_0\_rx\_task
\item \textbf{ can\_rx\_task} Responsible of checking if a CAN-message is available in the MOB. If any put them into the CAN\_rx\_queue
\item \textbf{ can\_tx\_task} Responsible of transmitting messages available in the CAN\_tx\_queue
\item \textbf{ aq\_node\_task} Responsible of registering the node when AQ boots.
\item \textbf{ task\_slip\_decode\_crc\_task} Responsible of running the SLIP \footnote{SLIP described in section \ref{sec:exp8266_firmware}} decapsulation of the received frames \footnote{SLIP described in section \ref{sec:exp8266_firmware}}. The At90CAN128 is not capable of handling the \ac{LLH} as doubles due to a limitation of the compiler,\footnote{The compiler used is AVR-GC++ to compile C++ to the At90CAN128, however it defaults handles a double as 4 bytes and not 8.} so instead the At90CAN128 represents doubles as byte arrays.
When a frame has been received it calculates the CRC of the payload and verifies the CRC bits are the same.
If so, the message is put into \textit{Queue\_gps\_pose} and sent to \textit{aq\_spoof \_task}
\item \textbf{ aq\_spoof\_task} Responsible of converting  received frames from \textit{Queue\_gps\_pose} to CAN messages \footnote{Messages shown in section \ref{sec:system_indoor_drone}}.
\end{itemize}

\subsection*{Test of CAN and Queues}
A test of the CAN and queues was conducted by sending a known ID and data to the extension-board over \ac{CAN}. The At90CAN128 then sent, using UART, to the PC what it received. Then test can be seen in appendix \ref{app:scheduler_and_can_test}.
As expected, the PC received the same ID and data as sent over CAN. This shows CAN and UART is configured correctly and that the queues transfer data between the tasks.
\subsection*{Test of scheduler}
%\input{scheduler_performance_test}
In order to test the timing of the scheduler, a led\_task was written. The task can be seen in code \ref{code:test_scheduler}
\begin{lstlisting}[language = c, caption = RTCS task used in timing test, label=code:test_scheduler]
void is_alive_task(uint8_t my_state){
	UDR0 = my_state+'0'; 	// Write state as ASCII to UART0
	switch(my_state){
	case 0:
		INT_LED_ON_GREEN;  // Other off
	    set_state( 1 );    // Set next state
		break;
	case 1:
		INT_LED_ON_RED;    // Other off
	    set_state( 2 );
		break;
	case 2:
		INT_LED_ON_BLUE;  // Other off
	    set_state( 0 );
		break;
	}
	wait( 1000 ); 	// Wait one second (1000 ticks = 1000 * 1ms )
}
\end{lstlisting}

The test was done by writing the current state of the task to UART0.\\ A python script were made that measures the time between each character received. The script can be seen in code \ref{code:test_rtcs_python}.
\begin{lstlisting}[language = python, caption = Python code used to measure time between received byte, label=code:test_rtcs_python]
# Imports
# Open serial port

t = time.time()
while True:
    char =  ser.read(1):
    print time.time() - t, ","
    t = time.time()

ser.close()
\end{lstlisting}
After receiving 700 bytes the standard deviation and mean was calculated using matlab.
The mean is 1.0089 sec with a standard deviation of 0.0042 sec.

Part of the variance is caused by the inaccuracy of the timing on the PC running the python code. If a more accurate measure was needed, a scope could be attached to the $\mu$C's GPIO. Each time the scheduler enters the task the GPIO should be set high, and when it exists the GPIO should be set low. This was not done due to lack of time.




